using Type, Format, Units
//==============================================================================================================
// Size and color information
//==============================================================================================================

let OutputFile = IO.Folders.Main IO.FileName("Family History") IO.Extensions.HTML

let Main.Run = [
  IO.Write(Watch, OutputFile),
  IO.OpenDocument(OutputFile),
]

with Metrics
  let CurrentDate    = System.Now
  let TreeText       = 5.5 pts
  let LevelIndent    = 0.25 inches
  let IconColor      = Color(73, 112, 163)
  let LineColor      = Color(62, 94, 136)
  let BoxColor       = Color(182, 199, 222)
  let DateIndent     = 1.35 inches
  let MainMargin     = Margin(0.75 inches, 0.75 inches, 0.75 inches, 0.75 inches)
  let TreeMargin     = Margin(0.5 inches, 0.125 inches, 0.125 inches, 0.5 inches)
  let Paper          = Size(8.5 inches, 11 inches)
  let Content        = Paper - MainMargin
  let TreeContent    = Paper - TreeMargin
  let StoryPicture   = Size(Content.Width, 3 inches)
  let PersonPicture  = Size(1.5 inches)
  let PortraitHeight = 1 inch
  let PortraitAngle  = 5 degrees
end
//=============================================================================================================

let Picture = {
  HasPicture: true,
}

let Nick(name) = {
  NickName: name
}

let Died(year, month=null, day=null) = {
  if (year == 0)
    DeathDateUnknown: true,
  else
    Death: DateTime(year, month, day)
  end
}

let Divorced(year, month=null, day=null) = {
  DivorceDate: DateTime(year, month, day)
}

let DatePlace(year, month, day, place) = {
  if (year)
    Date: DateTime(year, month, day),
  end,
  Place: place,
}

let Born(year, month=null, day=null, place=null)    = DatePlace(year, month, day, place)
let Married(year, month=null, day=null, place=null) = DatePlace(year, month, day, place)

let Formerly(name) = {
  Ne: name,
}

with Gender
  with Male
    let Icon = Styles.Icon(Chars.WhiteSquare)
  end

  with Female
    let Icon = Styles.Icon(Chars.WhiteCircle)
  end
end

with Stories end
with Unions end
with Persons end

with Places end

let AddPlace(city, state, country=null) = {
  Country: country ?? "USA",
  City: city,
  State: state
}

let ImagePath(person) = IO.Folders.Main IO.FileName(person.Name) IO.Extensions.JPG

let AddPicture(person, size) = IO.Read(person.ImagePath) {
  Size: size,
  Proportional: true
}

let Attendees(list, text) = Span {
  Span {
    Separator: ", ",
    ShowLink(each list),
  },
  text
}

let GatherEvent(event, list) begin
  if (event.Date)
    if (event.AddEvent)
      event.AddEvent(event, list)
    else
      list.AddElement(event)
    end
  end
end

let SortFunc(x, y) = Math.Compare(x.Date, y.Date)

let SortEvents(events) begin
  var sortlist = List(256);
  GatherEvent(each events, sortlist);
  return sortlist.Sort(false, SortFunc);
end

let GatherPicture(list, union) begin
  if (union.Partner1.HasPicture and union.Partner2.HasPicture)
    list.AddElement(union)
  end
end

let GatherPictures(unions) begin
  var list = List(256);
  GatherPicture(list, each unions);
  return list;
end

let PeopleAndUnions = Unions + People
let SortedEvents    = SortEvents(PeopleAndUnions + Stories)
let PictureList     = GatherPictures(Unions)

//===============================================================================================================
// Class definitions
//===============================================================================================================

with Event
  let New(class) = {
    DrawTimeline: class.DrawTimeline,
    AddEvent: class.?AddEvent,
    DrawListing: class.?DrawListing,
    FindChildren: class.?FindChildren,
    FormatNode: class.?FormatNode,
    ShowFull: class.?ShowFull
  }
end
//===============================================================================================================

let Female(first, middle, last, parent=null) = Event.New(Person) {
  First: first,
  Middle: middle,
  Last: last,
  Parent: parent,
  Icon: Gender.Female.Icon,
}

let Male(first, middle, last, parent=null) = Event.New(Person) {
  First: first,
  Middle: middle,
  Last: last,
  Parent: parent,
  Icon: Gender.Male.Icon,
}

with Person
  let AddEvent(event, list) begin
    list.AddElement(event);
    if (event.Death)
      list.AddElement(Passing.New(event));
    end
  end

  let FindChildren(event, set, parent) = set.AddElement(event) && event.Parent == parent

  let FormatNode(parent, event) = {
    Marker: TreePerson(null, event)
  }

  let DrawTimeline(event) = {
    ShowFullLink(event),
    Space,
    "was born"
  }

  let DrawListing(event, level) = Styles.LevelPar(level, false) {
    ShowListing(event)
  }

  let ShowFull(person) = Block {
    if (person.HasPicture)
      Paragraph {
        SpaceAfter: 10 pts,
        Group {
          Padding: 2 pts,
          VAlign: VAligns.Top,
          Frame {
            Width: Metrics.Content.Width - Metrics.PersonPicture.Width,
            ShowFullPersonData(person)
          },
          AddPicture(person, Metrics.PersonPicture),
        }
      }
    else
      ShowFullPersonData(person),
      Paragraph,
    end
  }
end
//===============================================================================================================

with Union
  let New(person1, person2, date=null) begin
    Assert(person1 and person2, "Expecting both partners");
    return Event.New(Union) {
      Date: date,
      Partner1: person1,
      Partner2: person2,
      Icon: Styles.Icon("\u2A01"),
    }
  end

  let FormatNode(parent, event) = {
    Marker: Group {
      Vertical: true,
//      Padding: 1 pts,
      Background: Metrics.BoxColor,
      TreePerson(parent, event.Partner1),
      TreePerson(parent, event.Partner2),
    }
  }

  let FindChildren(event, set, parent) begin
    set.AddElement(event.Partner1);
    set.AddElement(event.Partner2);
    return event.Partner1.Parent == parent or event.Partner2.Parent == parent;
  end

  let DrawTimeline(event) = {
    ShowFullLink(event.Partner1, true),
    Space,
    "married",
    Space,
    ShowFullLink(event.Partner2, true),
  }

  let DrawListing(event, level) = Block {
    Styles.LevelPar(level) {
      ShowListing(event.Partner1),
    },
    Styles.LevelPar(level) {
      Tab,
      Span {
        event.Icon,
        Space,
        TextColor: Metrics.IconColor
      },
      Styles.TextDate(Space, event.Date),
    },
    Styles.LevelPar(level) {
      ShowListing(event.Partner2),
    }
  }
end
//===============================================================================================================

with Passing
  let New(person) = Event.New(Passing) {
    Date: person.Death,
    Person: person,
    Icon: Styles.Icon("\u2A4D"),
  }

  let DrawTimeline(event) = Span {
    ShowFullLink(event.Person),
    " died",
    Styles.DiedAtAge(event.Person)
  }
end
//===============================================================================================================

with Story
  let New(toldby, title, date) = Event.New(Story) {
    Date: date,
    ToldBy: toldby,
    Title: title,
    Icon: Styles.Icon("\u25A4"),
  }

  let DrawTimeline(story) = Span {
    Popup: StoryPopup.Call(story),
    Link: story.Key,
    story.Title
  }

  let StoryPopup(story) = Frame {
    Width: Metrics.Content.Width - Metrics.StoryPicture.Width,
    story.Text,
  }

  let ShowFull(story) = Block {
    Paragraph {
      SpaceBefore: 16 pts,
      ParBackground: 90%,
      LocationMark: story.Key,
      Styles.ShowDate(story.Date),
      ": ",
      Span {
        Bold, Italic,
        story.Title
      },
      if (story.ToldBy)
        " as told by ",
        ShowFullLink(story.ToldBy)
      end
    },
    Block {
      story.Text,
      if (story.HasPicture)
        Paragraph {
          AddPicture(story, Metrics.StoryPicture),
        }
      end,
    }
  }
end
//============================================================================================================
// Document styles
//============================================================================================================

with Styles
  let Header1(text) = Paragraph {
    TextHeight: 18 pts,
    SpaceAfter: 12 pts,
    Bold,
    text
  }

  let Header2(text) = Paragraph {
    BorderB: 0.5,
    TextFamily: TextFamilies.Garamond,
    TextHeight: 16 pts,
    SpaceBefore: 12 pts,
    SpaceAfter: 6 pts,
    Bold,
    text
  }

  let Icon(text) = Span {
    TextFamily: TextFamilies.CambriaMath,
    text
  }

  let ShowDate(d) = Span {
    if (d.Precision == DatePrecisions.Year)
      TextFormat: "yyyy",
    else
      if (d.Precision == DatePrecisions.Month)
        TextFormat: "MMMM yyyy",
      else
        TextFormat: "MMMM dd, yyyy",
      end
    end,
    d,
  }

  let TimelineDate(d) = Span {
    if (d.Precision == DatePrecisions.Year)
      TextFormat: "yyyy",
    else
      if (d.Precision == DatePrecisions.Month)
        TextFormat: "yyyy, MMMM",
      else
        TextFormat: "yyyy, MMMM dd",
      end
    end,
    d,
  }

  let TextDate(text, d) begin
    if (d)
      return Span {
        text,
        Space,
        ShowDate(d),
      };
    else
      return null
    end
  end

  let ShowPlace(place) = Span {
    place.City,
    ", ",
    place.State,
  }

  let DiedAge(person) = Span {
    TextDate("Died ", person.Death),
    if (person.Date)
      DiedAtAge(person)
    end
  }

  let DiedAtAge(person) = Span {
     ", at age {0}"(Math.Floor((person.Death - person.Date).Years))
  }

  let LevelPar(level, border=true) = Paragraph {
    LeftIndent: level*Metrics.LevelIndent + 12 pts,
    FirstIndent: -12 pts,
    if (border)
      BorderL: 3 pts {Color: 90%, Padding: 3 pts},
    end
  }

  let Story = Paragraph {
    FirstIndent: 16 pts,
  }
end
//============================================================================================================

let ShowLink(person, text=null) = Span {
  Link: person.Key,
  Popup: PersonPopup.Call(person),
  TextColor: Colors.Blue,
  text ?? (person.NickName ?? person.First)
}

let ShowFullName(person, former=false) = Span {
  Separator: Space,
  person.First,
  person.Middle,
  if (former)
    person.Ne ?? person.Last,
  else
    person.Last
  end
}

let ShowFullLink(person, former=false) = ShowFullName(person, former) {
  Link: person.Key,
  Popup: PersonPopup.Call(person),
}

let ShowListing(person) = Span {
  person.Icon,
  Space,
  ShowFullLink(person),
  if (person.Ne)
    " (né {0})"(person.Ne)
  end,
  if (person.Death)
    Span {
      TextColor: Colors.DarkGray,
      Styles.TextDate(", died ", person.Death),
    }
  end
}

let FullPar = Paragraph {
  LeftIndent: Metrics.LevelIndent,
}

let ShowFullPersonData(person) = Block {
  FullPar {
    LocationMark: person.Key,
    LeftIndent: Metrics.LevelIndent,
    FirstIndent: -Metrics.LevelIndent,
    TextHeight: 16 pts,
    person.Icon,
    Tab,
    ShowFullName(person) {
      if (person.NickName)
        Span {
          " - \"",
          person.NickName,
          "\""
        },
      end,
    },
  },
  if (person.Ne)
    FullPar {
      Italic "né ",
      ShowFullName(person, true)
    }
  end

  if (person.Date)
    FullPar {
      if (person.DeathDateUnknown)
        "Unknown time of death",
      else
        if (not person.Death and (Metrics.CurrentDate - person.Date).Years < 100)
          "{0} years old"(Math.Floor((Metrics.CurrentDate - person.Date).Years))
        end,
      end,
    },
    FullPar {
      if (person.Date)
        Styles.TextDate("Born ", person.Date),
      end,
      if (person.Death)
        LineBreak,
        Styles.DiedAge(person)
      end,

      if (person.Place)
        " in ",
        Styles.ShowPlace(person.Place),
      end,
    },
  end,
}

let PersonPopup(person) = Frame {
  if (person.HasPicture)
    Width: Metrics.Content.Width,
  else
    Width: Metrics.Content.Width - Metrics.PersonPicture.Width,
  end,
  person.ShowFull(person)
}
//============================================================================================================
// Timeline
//============================================================================================================

with Timeline
  let MaxWidth    = Metrics.Content.Width
  let RowHeight   = 9 pts
  let TotalHeight = Metrics.Content.Height - 1 inch
  let Edge        = 12 pts
  let InnerWidth  = MaxWidth - Edge*2
  let MaxRows     = Math.Floor(Units.DivideUnits(Metrics.TotalHeight, RowHeight))
  let RowCount    = SortedEvents.Length div (SortedEvents.Length div MaxRows + 1)

  let AddEvent(event, yearstart, yearend) begin
    var frac = (event.Date.Year - yearstart) / (yearend - yearstart);
    var x    = InnerWidth * frac;
    if (frac > 0.5)
      return Canvas {
        Y: RowHeight * EachIndex,
        Width: x,
        HAlign: HAligns.Right,
        Span {
          event.DrawTimeline(event),
          Space,
          event.Icon {TextColor: Metrics.IconColor},
        }
      };
    else
      return Canvas {
        X: x,
        Y: RowHeight * EachIndex,
        Span {
          event.Icon {TextColor: Metrics.IconColor},
          Space,
          event.DrawTimeline(event)
        }
      };
    end
  end

  let ShowBlock(events) begin
    var yearstart  = (Math.Floor(events.FirstElement.Date.Year) div 10) * 10; // Round down to the nearest 10 years
    var yearend    = (Math.Floor(events.LastElement.Date.Year + 9) div 10) * 10; // Round up to the nearest 10 years

    return Paragraph {
      SpaceAfter: 10 pts,
      Group {
        Vertical: true,
        Paragraph {
          HAlignment: HAligns.Center,
          TextHeight: 12 pts,
          Bold,
          "Event Timeline",
        },
        Group {
          Vertical: true,
          ChartAxis {
            Width: MaxWidth,
            Start: yearstart,
            Stop: yearend,
          },
        },
        Canvas {
          X: Edge,
          Width: InnerWidth,
          Border: 0.25 pts,
          TextHeight: 8 pts,
          AddEvent(each events, yearstart, yearend),
        }
      }
    };
  end

  let AddRows(event) = Paragraph {
    LeftIndent: Metrics.DateIndent,
    FirstIndent: -Metrics.DateIndent,
    Styles.TimelineDate(event.Date),
    Tab,
    Tab,
    event.Icon {TextColor: Metrics.IconColor},
    Space,
    event.DrawTimeline(event)
  }

  let Show = Block {
    ShowBlock(each (SortedEvents / RowCount)),
    Styles.Header2("Timeline Details"),
    AddRows(each SortedEvents),
  }
end
//============================================================================================================
// Tree
//============================================================================================================

let FindChildData(c, data) begin
  c.FindChildren(c, data.Set, data.Parent)
end

let CollectChildren(list, c) begin
  var set = Dictionary(PeopleAndUnions.Length);
  return FindSlice(list, FindChildData, {Parent: c, Set: set});
end

let TreePerson(parent, person) = Group {
  VAlign: VAligns.Center,
  Span {
    Span {
      if (parent == person.Parent)
        TextColor: Colors.White,
      else
        TextColor: Metrics.IconColor,
      end
      person.Icon,
    },
    Space,
    Link: person.Key,
    Popup: PersonPopup.Call(person),
    person.NickName ?? person.First,
  }
}

let MakeTreeNodes(list, parent, event) = Node {
  event.FormatNode(parent, event),
  MakeTreeNodes(list, event, each CollectChildren(list, event))
}
//============================================================================================================
//  Family member listing
//============================================================================================================

let BuildListing(list, event, level) = Block {
  event.DrawListing(event, level),
  BuildListing(list, each CollectChildren(list, event), level+1),
}

let Leaf = Node {Marker: Gender.Female.Icon}

let IconTree = Node {
  Node {
    Leaf {Branch: 4},
    Node {
      Branch: 2,
      Leaf {Branch: 2},
      Node {
        Leaf, Leaf
      }
    }
  },
  Node {
    Branch: 3,
    Node {
      Leaf, Leaf
    },
    Leaf {Branch: 2}
  }
}

let HeaderFormat = Paragraph {
  TextHeight: 10 pts,
  TextFamily: TextFamilies.TimesNewRoman,
  BorderBottom: 0.25 pts,
};

let DocSection(title, name) = Section {
  SectionBreak: SectionBreaks.NextPage,
  Header: Block {
    Distance: 0.5 inches,
    HeaderFormat {
      ParAlignment: ParAlignments.Right,
      name
    },
    Even: Block {
      HeaderFormat {
        ParAlignment: ParAlignments.Left,
        title
      }
    },
    First: Block {
    }
  },
  Footer: Block {
    Distance: 0.5 inches,
    Paragraph {
      ParAlignment: ParAlignments.Center,
      PageNumber
    },
  },
}

let UnionTitle(union) = Span {
  ShowFullName(union.Partner1),
  " and ",
  ShowFullName(union.Partner2),
}

let TopColor    = 94%
let BottomColor = 80%

let PortraitFrame(person, angle) = Canvas {
  BorderT: 4 pts {Color: TopColor..BottomColor {Vertical: true}},
  BorderLR: 4 pts {Color: TopColor..BottomColor},
  BorderB: 4 pts {Color: TopColor..BottomColor {Vertical: true}},

  Transform: Rotate(angle) Skew(angle, angle),
  IO.Read(person.ImagePath) {
    Link: person.Key,
    Popup: PersonPopup.Call(person),
    Size: Size(Metrics.PortraitHeight),
    Proportional: true,
  },
}

let ShowPortrait(union) = Group {
  VAlign: VAligns.Top,
  PortraitFrame(union.Partner1, -Metrics.PortraitAngle),
  Canvas {
    MarginTB: 8 pts,
    Width: 2 pts,
    Height: Metrics.PortraitHeight,
    Background: 60%,
  },
  PortraitFrame(union.Partner2, Metrics.PortraitAngle),
}

let ShowPortraitLine(unions) = Group {
  Separator: Space*3,
  ShowPortrait(each unions)
}

let AlbumTitlePage(title) = Section {
  SectionBreak: SectionBreaks.NextPage,
  ParAlignment: ParAlignments.Center,
  Paragraph {
    SpaceBefore: 1 inches,
    TextHeight: 36 pts,
    title,
  },
  Paragraph {
    Tree {
      Height: 60 pts,
      Marker: Styles.Icon(Chars.Square) {TextColor: Metrics.BoxColor},
      Vertical: true,
      Reverse: true,
      Stroke: 2 pts {Color: Metrics.LineColor},
      Curvature: 20%,
      Bevel: 20%,
      NodeGap: 20 pts,
      IconTree
    },
    SpaceAfter: 20 pts,
  },
  Paragraph {
    Group {
      Vertical: true,
      HAlign: HAligns.Center,
      ShowPortraitLine(each (PictureList / 4))
    }
  },
  Paragraph {
    SpaceBefore: 1 inches,
    TextHeight: 16 pts,
    Styles.ShowDate(Metrics.CurrentDate)
  },
}

let ShowFullEvent(event) = Block {
  event.ShowFull(event)
}

let ShowFullEvents(list, title) begin
  if (list.Length > 0)
    return Block {
      PageBreak,
      Styles.Header2(title),
      ShowFullEvent(each list),
    }
  end
end


let ShowFamilyLine(title, union) = DocSection(title, UnionTitle(union)) {
  SectionBreak: SectionBreaks.NextPage,
  Styles.Header2("Tree Details"),
  BuildListing(PeopleAndUnions, union, 0),
}

let ShowDetails(title) = DocSection(title, "Details") {
  Timeline.Show,
  ShowFullEvents(Stories, "Stories"),
  ShowFullEvents(People, "Family Members"),
}

let ShowSource(title) = DocSection(title, "Source Data") {
  Paragraph {
    TextHeight: 8 pts,
    SourceSelection(System.SourceList[0])
  }
}

let ShowTree(title, union) = Section {
  SectionBreak: SectionBreaks.NextPage,
  Margin: Metrics.TreeMargin,
  Styles.Header1("The Decendants of " UnionTitle(union)),
  Tree {
    TextHeight: Metrics.TreeText,
    Width: Metrics.TreeContent.Width,
    Bevel: 10%,
    Curvature: 10%,
    Stroke: 0.25 pts {Color: Metrics.LineColor},
    MakeTreeNodes(PeopleAndUnions, null, union),
  },
  ShowFamilyLine(title, union),
}

let FamilyAlbum(title, lines) = Document {
  Size: Metrics.Paper,
  Margin: Metrics.MainMargin,
  AlbumTitlePage(title),
  ShowTree(title, each lines),
  ShowDetails(title),
//  ShowSource(title),
}
//============================================================================================================


